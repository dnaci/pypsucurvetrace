#!/usr/bin/env python3

# This file is part of PyPSUcurvetrace, a toolbox for I/V curve tracing of electronic parts using programmable power supplies.
#
# PyPSUcurvetrace is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# PyPSUcurvetrace is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with PyPSUcurvetrace.  If not, see <http://www.gnu.org/licenses/>.

import traceback
import argparse
import configparser
import datetime
import numpy as np
import time
import logging
logging.basicConfig(level=logging.DEBUG)

import lib.powersupply as powersupply
import lib.heaterblock as heaterblock

from lib.curvetrace_tools import printit, connect_PSU, configure_test_PSU, configure_idle_PSU, do_idle, start_new_logfile




###################
# cleanup at exit #
###################

def cleanup_exit():
	# Try hard to turn off all PSUs to avoid unwanted/unattended powering of the DUT or heater block.

	for p in [PSU1, PSU2]:
		try:
			if p.CONNECTED:
				p.turnOff()
		except:
			logging.warning('Could not turn off PSU ' + p.LABEL + '!')
			pass

	try:
		HEATER.turn_off()
	except:
		logging.warning('Could not turn off heater: ' +  traceback.format_exc())
		pass
	try:
		HEATER.terminate_controller_thread()
	except:
		logging.warning('Could not terminate heaterblock controller thread: ' +  traceback.format_exc())
		pass



################
# main program #
################

# parse input arguments (if any):
parser = argparse.ArgumentParser(description='PyPSUcurvetrace is a Python program for I-V curve tracing of electronic parts using programmable power supplies.')
parser.add_argument('-c', help='configuration file with test parameters [name/path]')
parser.add_argument('-b', action='store_true', help='Batch mode (loop of repeated test tuns)')
parser.add_argument('-q', action='store_true', help='Quick mode (pre-heating only, no curve tracing)')
args = parser.parse_args()

# Say Hello:
print('\n')
print('***** PyPSUcurvetrace')
print('***** Python program for I-V curve tracing of electronic parts using programmable power supplies')
print('***** Disclaimer: NO WARRANTIES OF ANY KIND!!!')
print('***** Disclaimer: Users are advised to study the code in order to understand how this program works.')
print('\n')

# read PSU config file:
configTESTER = configparser.ConfigParser()
configTESTER.read('config.txt')

# check for batch mode:
batch_mode = False
if args.b:
	print ('Running in batch mode (loop of repeated test tuns)...\n')
	batch_mode = True

# check for quick mode:
quick_mode = False
if args.q:
	print ('Running in quick mode (pre-heating only, no curve tracing)...\n')
	quick_mode = True

# read DUT configTESTER file (if any):
configDUT = []
if args.c:
	print ('Reading DUT configuration in file ' + args.c + '...\n')
	configDUT = configparser.ConfigParser()
	configDUT.read(args.c)
	
# connect to PSUs:
PSU1 = connect_PSU(configTESTER,'PSU1'); print( )
PSU2 = connect_PSU(configTESTER,'PSU2'); print( )

# set up heaterblock:
HEATER = heaterblock.heater( config=configTESTER, target_temperature=0.0 )
HEATER.turn_off()

logfile, samplename, basename, step = start_new_logfile(batch_mode)

# configure voltage values / current and power limits:
if 'PSU1' in configDUT:
	PSU1 = configure_test_PSU (PSU1,configDUT['PSU1'])
else:
	PSU1 = configure_test_PSU (PSU1)
if 'PSU2' in configDUT:
	PSU2 = configure_test_PSU (PSU2,configDUT['PSU2'])
else:
	PSU2 = configure_test_PSU (PSU2)

# check if at least one of the power supplies is configured:	
if not PSU1.CONFIGURED:
	if not PSU2.CONFIGURED:
		print('No power supply configured. Good bye.')
		exit()

# set up temperature control (optional, may be missing in DUT config file):
TEMP_val = None
TEMP_tol = None
try:
	TEMP_val = float(configDUT['EXTRA']['T_TARGET'])
	TEMP_tol = float(configDUT['EXTRA']['T_TOL'])
except:
	pass
HEATER.set_target_temperature(TEMP_val, TEMP_tol)

# set up repeats:
if 'EXTRA' in configDUT:
	N_rep = int(configDUT['EXTRA']['NREP'])
else:
	try:
		N_rep = int(input('\nOPTIONAL: Number of repeats per reading [default=1]: '))
	except ValueError:
		print ('  Using default: single reading.')
		N_rep = 1
if N_rep <= 0:
	raise ValueError('Number of repeats must be positive.')

# set up idle time between readings:
if 'EXTRA' in configDUT:
	T_idle    = float(configDUT['EXTRA']['IDLESECS'])
else:
	try:
		T_idle = float(input('\nOPTIONAL: idle time between readings (s) [default=0]: '))
	except ValueError:
		print ('  Using default: no idle time.')
		T_idle = 0.0
if T_idle < 0:
	raise ValueError('Idle time must not be negative.')

# set up pre-heat time between readings:
if 'EXTRA' in configDUT:
	T_preheat    = float(configDUT['EXTRA']['PREHEATSECS'])
else:
	try:
		T_preheat = float(input('\nOPTIONAL: pre-heat time before starting the test (s) [default=0]: '))
	except ValueError:
		print ('  Using default: no pre-heating.')
		T_preheat = 0.0
if T_preheat < 0:
	raise ValueError('Pre-heat time must not be negative.')

# set up idle conditions (for pre-heat or idle between readings)
if (T_idle > 0.0) or (T_preheat > 0.0):
	if PSU1.CONFIGURED:
		if 'PSU1' in configDUT:
			PSU1 = configure_idle_PSU (PSU1,configDUT['PSU1'])
		else:
			PSU1 = configure_idle_PSU (PSU1,None)
	if PSU2.CONFIGURED:
		if 'PSU2' in configDUT:
			PSU2 = configure_idle_PSU (PSU2,configDUT['PSU2'])
		else:
			PSU2 = configure_idle_PSU (PSU2,None)

	if PSU1.CONNECTED and PSU2.CONNECTED:
		if (not PSU1.TEST_VIDLE_MAX == PSU1.TEST_VIDLE_MIN) and (not PSU2.TEST_VIDLE_MAX == PSU2.TEST_VIDLE_MIN):
			print('Both PSUs are configured with variable idle voltages. This cannot work. Goodbye!')
			exit()

# check voltage / power / current limits (and fix where possible and necessary):
print ('\nChecking voltage / current settings...')
for p in [PSU1,PSU2]:
	if p.CONNECTED:
		if p.TEST_VSTART < p.VMIN:
			print ('  ' + p.LABEL + ': Adjusting start voltage to min. value possible with the power supply (' + str(p.VMIN) + ' V).')
			p.TEST_VSTART = p.VMIN
		if p.TEST_VSTART > p.VMAX:
			print ('  ' + p.LABEL + ': Adjusting start voltage to max. value possible with the power supply (' + str(p.VMAX) + ' V).')
			p.TEST_VSTART = p.VMAX
		if p.TEST_VEND < p.VMIN:
			print ('  ' + p.LABEL + ': Adjusting end voltage to min. value possible with the power supply (' + str(p.VMIN) + ' V).')
			p.TEST_VEND = p.VMIN
		if p.TEST_VEND > p.VMAX:
			print ('  ' + p.LABEL + ': Adjusting end voltage to max. value possible with the power supply (' + str(p.VMAX) + ' V).')
			p.TEST_VEND = p.VMAX
		if p.TEST_VEND == p.TEST_VSTART:
			# print ('  ' + p.LABEL + ': Same start and end voltage, test will run at fixed voltage (' + str(p.TEST_VSTART) + ' V).')
			p.TEST_VSTEP = 0
		if abs(p.TEST_VEND-p.TEST_VSTART) < p.VRESSET:
			print ('  ' + p.LABEL + ': Test voltage range is less than voltage setting resolution of the PSU. Test will run at fixed voltage (' + str(p.TEST_VSTART) + ' V).')
			p.TEST_VSTEP = 0
			p.TEST_VEND = p.TEST_VSTART
		if p.TEST_VSTEP > 0.0:
			if p.TEST_VSTEP > abs(p.TEST_VEND-p.TEST_VSTART):
				p.TEST_VSTEP = abs(p.TEST_VEND-p.TEST_VSTART)
				print ('  ' + p.LABEL + ': Voltage step size exceeds test voltage range. Adjusting step size to ' + str(p.TEST_VSTEP) + ' V.')
			if p.TEST_VSTEP < p.VRESSET:
				print ('  ' + p.LABEL + ': Voltage step size is less than PSU resolution of voltage setting. Adjusting step size to ' + str(p.VRESSET) + ' V.')
				p.TEST_VSTEP = p.VRESSET
			if p.TEST_VSTEP/p.VRESSET < p.VRESSET:
				print ('  ' + p.LABEL + ': Voltage step size is less than PSU resolution of voltage setting. Adjusting step size to ' + str(p.VRESSET) + ' V.')
				p.TEST_VSTEP = p.VRESSET
			if not ( p.TEST_VSTEP / p.VRESSET == round(p.TEST_VSTEP / p.VRESSET) ):
				u = p.TEST_VSTEP
				p.TEST_VSTEP = round(p.TEST_VSTEP / p.VRESSET) * p.VRESSET
				print ('  ' + p.LABEL + ': Voltage step size (' + str(u) + ' V) is not consistent with PSU resolution of voltage setting. Adjusting step size to ' + str(p.TEST_VSTEP) + ' V.')
		if p.TEST_ILIMIT > p.IMAX:
			print ('  ' + p.LABEL + ': Adjusting current limit to max. value possible with the power supply (' + str(p.IMAX) + ' A).')
			p.TEST_ILIMIT = p.IMAX
		if p.TEST_PLIMIT > p.PMAX:
			print ('  ' + p.LABEL + ': Adjusting power limit to max. value possible with the power supply (' + str(p.PMAX) + ' W).')
			p.TEST_PLIMIT = p.PMAX
		if (T_idle > 0.0) or (T_preheat > 0.0):
			if p.TEST_PIDLELIMIT > p.PMAX:
				print ('  ' + p.LABEL + ': Adjusting idle power limit to max. value possible with the power supply (' + str(p.PMAX) + ' W).')
				p.TEST_PIDLELIMIT = p.PMAX
			if p.TEST_VIDLE > p.VMAX:
				print ('  ' + p.LABEL + ': Adjusting idle voltage to max. value possible with the power supply (' + str(p.VMAX) + ' V).')
				p.TEST_VIDLE = p.VMAX
			if p.TEST_VIDLE < p.VMIN:
				print ('  ' + p.LABEL + ': Adjusting idle voltage to min. value possible with the power supply (' + str(p.VMIN) + ' V).')
				p.TEST_VIDLE = p.VMIN
			if p.TEST_VIDLE_MAX > p.VMAX:
				print ('  ' + p.LABEL + ': Adjusting max.-idle voltage to max. value possible with the power supply (' + str(p.VMAX) + ' V).')
				p.TEST_VIDLE_MAX = p.VMAX
			if p.TEST_VIDLE_MAX < p.VMIN:
				print ('  ' + p.LABEL + ': Adjusting max.-idle voltage to min. value possible with the power supply (' + str(p.VMIN) + ' V).')
				p.TEST_VIDLE_MAX = p.VMIN
			if p.TEST_VIDLE_MIN > p.VMAX:
				print ('  ' + p.LABEL + ': Adjusting min.-idle voltage to max. value possible with the power supply (' + str(p.VMAX) + ' V).')
				p.TEST_VIDLE_MIN = p.VMAX
			if p.TEST_VIDLE_MIN < p.VMIN:
				print ('  ' + p.LABEL + ': Adjusting min.-idle voltage to min. value possible with the power supply (' + str(p.VMIN) + ' V).')
				p.TEST_VIDLE_MIN = p.VMIN
			if p.TEST_VIDLE_MIN > p.TEST_VIDLE_MAX:
				print ('  ' + p.LABEL + ': Adjusting min.-idle voltage to ' + str(p.TEST_VIDLE) + ' V).')
				p.TEST_VIDLE_MIN = p.TEST_VIDLE
			if p.TEST_VIDLE_MAX < p.TEST_VIDLE_MIN:
				print ('  ' + p.LABEL + ': Adjusting max.-idle voltage to ' + str(p.TEST_VIDLE) + ' V).')
				p.TEST_VIDLE_MAX = p.TEST_VIDLE
			if p.TEST_IIDLE > p.IMAX:
				print ('  ' + p.LABEL + ': Adjusting idle current to max. value possible with the power supply (' + str(p.IMAX) + ' V).')
				p.TEST_IIDLE = p.IMIN
			if p.TEST_VIDLE * p.TEST_IIDLE > p.PMAX:
				p.TEST_IIDLE = p.PMAX / p.TEST_VIDLE
				print ('  ' + p.LABEL + ': Idle current limit is higher than PSU power limit (' + str(p.PMAX) + ' W). Adjusting idle current limit to ' + str(p.TEST_IIDLE) + ' A.' )
		


# Print summary of test setup:
print('\nTest setup:')
for p in [PSU1, PSU2]:
	
	if not p.CONNECTED:
		print ('* ' + p.LABEL + ': Not connected')
	elif not p.CONFIGURED:
		print ('* ' + p.LABEL + ': Test parameters not configured')
	else:
		print ('* ' + p.LABEL + ':')
		for k in range(len(p._PSU)):
			if len(p._PSU) == 1:
				print ('  - Type: ' + str(p._PSU[k].COMMANDSET) + ' / ' + p._PSU[k].MODEL)
			else:
				print ('  - Type (unit '+str(k+1)+'): ' + str(p._PSU[k].COMMANDSET) + ' / ' + p._PSU[k].MODEL)

		if p.TEST_VSTEP == 0:
			print ('  - voltage output = ' + str(p.TEST_VSTART) + ' V (fixed)')
		else:
			print ('  - voltage output = ' + str(p.TEST_VSTART) + ' V ... ' + str(p.TEST_VEND) + ' V (' + str(p.TEST_VSTEP) + ' V steps)')
		print ('  - current limit = ' + str(p.TEST_ILIMIT) + ' A')
		print ('  - power limit = ' + str(p.TEST_PLIMIT) + ' W')
		if p.TEST_POLARITY == 1:
			print ('  - polarity: normal')
		else:
			print ('  - polarity: inverted')

print ('* Repeats per reading = ' + str(N_rep))
if T_idle == 0.0:
	print ('* No idle time between measurements')
else:
	print ('* Idle time between measurements: ' + str(T_idle) + ' s')
if T_preheat == 0.0:
	print ('* No pre-heating before measurements')
else:
	print ('* Pre-heat time before measurements (at idle conditions): ' + str(T_preheat) + ' seconds')
if (T_idle > 0.0) or (T_preheat > 0.0):
	for p in [PSU1, PSU2]:
		if p.CONNECTED == False:
			print ('* ' + p.LABEL + ' Idle / pre-heat conditions not configured')
		else:
			if p.TEST_VIDLE_MAX == p.TEST_VIDLE_MIN:
				print ('* ' + p.LABEL + ' idle / pre-heat voltage = ' + str(p.TEST_VIDLE) + ' V (fixed value)')
			else:
				print ('* ' + p.LABEL + ' idle / pre-heat voltage range = ' + str(p.TEST_VIDLE_MIN) + ' V ... ' + str(p.TEST_VIDLE_MAX) + ' V.')
			print ('* ' + p.LABEL + ' idle / pre-heat current = ' + str(p.TEST_IIDLE) + ' A')
			print ('* ' + p.LABEL + ' max. idle / pre-heat power = ' + str(p.TEST_PIDLELIMIT) + ' W')

print ('* Heaterblock temperature (current) = ' + str(HEATER.get_temperature_string()))
print ('* Heaterblock temperature (target)  = ' + str(HEATER.get_target_temperature_string()))





AVGFUNCTION = 'MEAN'
# AVGFUNCTION = 'MEDIAN'





#? I1LIM = 0.0
#? I2LIM = 0.0

# determine voltage step values:
V_steps = []

for p in [PSU1,PSU2]:
	if not p.CONFIGURED:
		V_steps.append( [ 0 ] )
	else:
		if p.TEST_VSTEP == 0:
			# V_steps.append( np.linspace(p.TEST_VSTART,p.TEST_VSTART,1) )
			V_steps.append( [ p.TEST_VSTART ] )
		else:
			if p.TEST_VSTART <= p.TEST_VEND:
				u = np.arange( p.TEST_VSTART , p.TEST_VEND+PSU1.TEST_VSTEP ,  p.TEST_VSTEP )
				u = [i for i in u if (i >= p.TEST_VSTART) and (i <= p.TEST_VEND) ] # filter out "outliers" that may happen with large VSTEPs
			else:
				u = np.arange( p.TEST_VSTART , p.TEST_VEND-PSU1.TEST_VSTEP , -p.TEST_VSTEP )
				u = [i for i in u if (i >= p.TEST_VEND) and (i <= p.TEST_VSTART) ] # filter out "outliers" that may happen with large VSTEPs
			V_steps.append(u)

try:
	do_run = True
	while do_run:

		# Ask if okay to start the test
		input ('\nReady for testing of ' + samplename + '? Press ENTER to start testing or CTRL+C to abort...')

		# Print header / column labels:
		printit('* Sample: ' + samplename,logfile,'%', terminal_output=False)
		printit('* Date / time: ' + str(datetime.datetime.now()),logfile,'%', terminal_output=False)
		if quick_mode:
			printit ('* Running in quick mode (pre-heating only, no curve tracing)',logfile,'%', terminal_output=False)
		else:
			printit ('Column 1:  PSU1 nominal voltage setting (V)',logfile,'%', terminal_output=False)
			printit ('Column 2:  PSU1 nominal current setting (A)',logfile,'%', terminal_output=False)
			printit ('Column 3:  PSU1 voltage measurement (V)',logfile,'%', terminal_output=False)
			printit ('Column 4:  PSU1 current measurement (I)',logfile,'%', terminal_output=False)
			printit ('Column 5:  PSU1 limiter flag',logfile,'%', terminal_output=False)
			printit ('Column 6:  PSU2 nominal voltage setting (V)',logfile,'%', terminal_output=False)
			printit ('Column 7:  PSU2 nominal current setting (A)',logfile,'%', terminal_output=False)
			printit ('Column 8:  PSU2 voltage measurement (V)',logfile,'%', terminal_output=False)
			printit ('Column 9:  PSU2 current measurement (I)',logfile,'%', terminal_output=False)
			printit ('Column 10: PSU2 limiter flag',logfile,'%', terminal_output=False)
			printit ('Column 11: Heaterblock temperature (°C)',logfile,'%', terminal_output=False)

		print ('\n')

		# Make sure the heater is turned on (if possible/configured):
		HEATER.turn_on()

		# if heaterblock is configured and turned on:
		# make sure the heaterblock temperature is within tolerance before configuring the measurement,
		HEATER.wait_for_stable_T(DUT_PSU_allowed_turn_off=None, terminal_output=True)
		
		# turn on PSU outputs:
		for p in [PSU1, PSU2]:
			if p.CONFIGURED:
				p.setCurrent(0,False)
				p.setVoltage(p.VMIN,False)
				p.turnOn()

		# DUT break-in / pre-heat
		if T_preheat > 0.0:
			
			print ('DUT break-in / pre-heat...\n')

			# set idle conditions:
			if TEMP_val != None:
				do_TEMP_wait = True
			else:
				do_TEMP_wait = False
			do_idle(PSU1,PSU2,HEATER,T_preheat,file=logfile,wait_for_TEMP=do_TEMP_wait)

		if not quick_mode:
			print ('Curve tracing started...\n')

			for V2 in V_steps[1]:
			# outer loop (V2)

				# get rid of numerical imprecisions (truncate values to voltage resolution of PSU):
				# V2 = round(V2/PSU2.VRESSET) * PSU2.VRESSET

				limit = 0 # number of CC events at a given step
				limit_max = 2 # max. number of CC events before breaking from the loop


				if PSU2.CONFIGURED:

					# Determine PSU2 current limit (based on DUT limits):
					if V2 > 0.0:
						I2LIM = min (PSU2.TEST_ILIMIT,PSU2.TEST_PLIMIT/V2)
					else:
						I2LIM = PSU2.TEST_ILIMIT

					# Check if current limit is within power capability of PSU2 (and adjust if necessary):
					if (V2*I2LIM) > PSU2.PMAX:
						I2LIM = PSU2.PMAX / V2
					
					# set PSU2 voltage + current:
					PSU2.setCurrent(I2LIM,False)
					PSU2.setVoltage(V2,True)

				for V1 in V_steps[0]:
				# inner loop (V1)

					# get rid of numerical imprecisions (truncate values to voltage resolution of PSU):
					# V1 = round(V1/PSU1.VRESSET) * PSU1.VRESSET

					# init measurement values		
					V1MEAS = []
					I1MEAS = []
					LIMIT1 = 0
					V2MEAS = []
					I2MEAS = []
					LIMIT2 = 0
					T_HB   = []

					# measurement loop:
					for i in range(N_rep):

						# if heaterblock is configured and turned on:
						# make sure the heaterblock temperature is within tolerance before doing the measurement,
						# allow turning off the DUT to prevent heat input from DUT to heaterblock
						HEATER.wait_for_stable_T(DUT_PSU_allowed_turn_off=PSU1, terminal_output=True)

						# idle (if configured)
						if T_idle > 0.0:
							do_idle(PSU1,PSU2,HEATER,T_idle)

							# return to required PSU2 output:
							if PSU2.CONFIGURED:
								PSU2.setCurrent(I2LIM,False)
								PSU2.setVoltage(V2,True)

						# Determine PSU1 current limit:
						if V1 > 0.0:
							I1LIM = min (PSU1.TEST_ILIMIT,PSU1.TEST_PLIMIT/V1)
						else:
							I1LIM = PSU1.TEST_ILIMIT

						# Check if current limit is within power capability of PSU1 (and adjust if necessary):
						if (V1*I1LIM) > PSU1.PMAX:
							I1LIM = PSU1.PMAX / V1

						# set up PSU1 measurement conditions:
						if PSU1.CONFIGURED:
							PSU1.setCurrent(I1LIM,False) # set current limit at PSU1
							PSU1.setVoltage(V1,True) # set voltage at PSU1

						# wait a bit to get stable conditions before taking the reading:
						time.sleep(0.2)

						# read PSU output voltages and currents:
						r = []
						for p in [PSU1, PSU2]:
							if p.CONFIGURED:
								r.append(p.read(p.NSTABLEREADINGS))
							else:
								r.append([0.0,0.0,'NONE'])
						
						V1MEAS.append(r[0][0])
						I1MEAS.append(r[0][1])
						V2MEAS.append(r[1][0])
						I2MEAS.append(r[1][1])
						if r[0][2] == 'CC':
							LIMIT1 = LIMIT1 + 1
						if r[1][2] == 'CC':
							LIMIT2 = LIMIT2 + 1

						# Determine heaterblock temperature:
						T_HB.append(HEATER.get_temperature())

					# Determine median or mean of repeated readings:
					if AVGFUNCTION == 'MEDIAN':
						V1MEAS = np.median(V1MEAS)
						I1MEAS = np.median(I1MEAS)
						V2MEAS = np.median(V2MEAS)
						I2MEAS = np.median(I2MEAS)
						T_HB   = np.median(T_HB)
					else:
						V1MEAS = np.mean(V1MEAS)
						I1MEAS = np.mean(I1MEAS)
						V2MEAS = np.mean(V2MEAS)
						I2MEAS = np.mean(I2MEAS)
						T_HB   = np.mean(T_HB)
						
					# Check current limits (some PSUs are not very careful with this):
					if I1MEAS > I1LIM:
						LIMIT1 = 1
					if I2MEAS > I2LIM:
						LIMIT2 = 1

					# Parse limiter flags:
					if LIMIT1 > 0:
						LIMIT1 = 1
					else:
						LIMIT1 = 0
					if LIMIT2 > 0:
						LIMIT2 = 1
					else:
						LIMIT2 = 0

					# Check if current / power limit has been reached:
					if (LIMIT1 == 0) and (LIMIT2 == 0):
						limit = 0 # reset counter
					else:
						limit = limit + 1
						if limit >= limit_max:
							break # break out of the inner loop (V1 steps) and continue with the next V2 step

					# Print results:
					printit (	"{:10.6f}".format(V1*PSU1.TEST_POLARITY)	+ ' ' + 
							"{:10.6f}".format(I1LIM*PSU1.TEST_POLARITY)	+ ' ' + 
							"{:10.6f}".format(V1MEAS*PSU1.TEST_POLARITY)	+ ' ' +
							"{:10.6f}".format(I1MEAS*PSU1.TEST_POLARITY)	+ ' ' + 
							"{:5d}".format(LIMIT1)				+ ' ' +
							"{:10.6f}".format(V2*PSU2.TEST_POLARITY)	+ ' ' +
							"{:10.6f}".format(I2LIM*PSU2.TEST_POLARITY)	+ ' ' +
							"{:10.6f}".format(V2MEAS*PSU2.TEST_POLARITY)	+ ' ' +
							"{:10.6f}".format(I2MEAS*PSU2.TEST_POLARITY)	+ ' ' +
							"{:5d}".format(LIMIT2)                          + ' ' +
							"{:.2f}".format(T_HB) ,
						logfile )

			print ('Curve tracing completed.')
	
		if batch_mode:
			# prepare next step and file:
			logfile, samplename, _, step = start_new_logfile(batch_mode, basename, step+1)
		else:
			do_run = False

except KeyboardInterrupt:
	print ('\nCaught keyboard interrupt, exiting...\n')
	
except:
	print ('\nOooops, something went wrong during testing: ' +  traceback.format_exc())

finally:
	cleanup_exit()
