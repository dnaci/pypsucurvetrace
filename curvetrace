#!/usr/bin/env python3

# Curve tracer program:
# Use one PPS power supply to determine a single trace of a two-terminal DUT:
# * Read configuration file (for PPS PSU connections)
# * Ask for sample name and start a log file for the test
# * Ask for the min. and max. voltage to be applied to the DUT
# * Ask for number of voltage steps
# * Ask for current limit (max. current allowed for the DUT)
# * Ask for power limit (max. power allowed for the DUT)
# * Apply specified voltages to to DUT and read the current
# * Output the voltage / current data
#
# Hardware setup:
# * Computer connected to programmable Voltcraft PPS power supply via USB cable (UART interface in PPS)
# * DUT device connected to power supply output:
#	PSU-POS -- DUT-1
#	PSU-NEG -- DUT-2
#
# This file is part of curvetracePy, a toolbox for curve tracing using programmable Voltcraft PPS power supplies.
#
# curvetracePy is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# curvetracePy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with ruediPy.  If not, see <http://www.gnu.org/licenses/>.
# 
# curvetracePy: a toolbox for operation of PEM electrolysis cells.
# Copyright 2020, Matthias Brennwald (mbrennwa@gmail.com)

# make shure Python knows where to look for the curvetracePy Python code
# http://stackoverflow.com/questions/4580101/python-add-pythonpath-during-command-line-module-run
# Example (bash): export PYTHONPATH=~/curvetracePy

# imports:
### import argparse
### import datetime
import time
import math
import configparser
import numpy as np
from termcolor import colored
import powersupply_PPS


#############################################################
# function to print output both to console and to data file #
#############################################################

def printit(text,f='',comm=''):
	# print date/time followed by text either to stdout (if f is empty) or to file (if f is not empty)
	# prepend date/time:
	# now = datetime.datetime.now()
	# text = now.strftime("%Y-%m-%d %H:%M:%S") + '\t' + text

	#print text:
	print(text)
	if f:
		if len(comm):
			text = comm + ' ' + text
		print(text,file=f)
		f.flush()
	return


###########################
# connect to power supply #
###########################

def connect_PSU(config,label):
	
	if len(config[label]['COMPORT']) == 0:
		print('COM port for power supply ' + label + 'empty. Leaving ' + label + ' uN2onfigured.')
		PSU.VMAX = 0.0
		PSU.VMIN = 0.0
		PSU.IMAX = 0.0
		PSU.TSETTLE = 0.0
		PSU.MODEL = 'NONE'
		PSU.connected = False

	else:
		# connect to PSU:
		print ('Connecting to power supply ' + label + '...')
		PSU = powersupply_PPS.PPS(port=config[label]['COMPORT'], reset=False, prom=None)
		PSU.output(False) # make sure it is turned off

		# determine minimum voltage of the PSU:
		PSU.VMIN = float(config[label]['VOLTAGE_MIN'])

		# determine settle time:
		PSU.TSETTLE = float(config[label]['SETTLE_SECONDS'])

		# turn on PSU with zero output:
		PSU.voltage(PSU.VMIN)
		PSU.current(0)
		PSU.output(True)

		PSU.label = label		

		PSU.connected = True

		# show summary
		print ('* Type: ' + PSU.MODEL)
		print ('* Min. voltage output: ' + str(PSU.VMIN) + ' V')
		print ('* Max. voltage output: ' + str(PSU.VMAX) + ' V')
		print ('* Max. current output: ' + str(PSU.IMAX) + ' A')
		print ('* Settle time: ' + str(PSU.TSETTLE) + ' s')
		print ()

	PSU.PMAX = math.floor(PSU.VMAX*PSU.IMAX)

	return PSU



###############################
# configure PSU test settings #
###############################

def configure_PSU(PSU):
	
	if PSU.connected == False:
		print ('\n' + PSU.label + ' is not connected (or connection is not configured).')
		PSU.configured = False
	else:
		print ('\n' + 'Configure ' + PSU.label + ' settings:')

		try:
			PSU.VSTART = float(input('* ' + PSU.label + ' start voltage (V): '))
		except ValueError:
			print ('  Invalid input!')
		if PSU.VSTART < PSU.VMIN:
			print ('  Adjusting start voltage to min. value possible with the power supply (' + str(PSU.VMIN) + ' V).')
			PSU.VSTART = PSU.VMIN
		if PSU.VSTART > PSU.VMAX:
			print ('  Adjusting start voltage to max. value possible with the power supply (' + str(PSU.VMAX) + ' V).')
			PSU.VSTART = PSU.VMAX

		try:
			PSU.VEND = float(input('* ' + PSU.label + ' end voltage (V): '))
		except ValueError:
			print ('  Invalid input!')
		if PSU.VEND < PSU.VMIN:
			print ('  Adjusting end voltage to min. value possible with the power supply (' + str(PSU.VMIN) + ' V).')
			PSU.VEND = PSU.VMIN
		if PSU.VEND > PSU.VMAX:
			print ('  Adjusting end voltage to max. value possible with the power supply (' + str(PSU.VMAX) + ' V).')
			PSU.VEND = PSU.VMAX

		if PSU.VSTART == PSU.VEND:
			PSU.N = 1;
		else:
			try:
				PSU.N = int(input('* ' + PSU.label + ' number of voltage steps: '))
			except ValueError:
				print ('  Invalid input!')		
			if PSU.N < 2:
				print ('  Invalid number of voltage steps. Using N = 2...')
				PSU.N = 2


		try:
			PSU.ILIMIT = float(input('* ' + PSU.label + ' maximum allowed current (A): '))
		except ValueError:
			print ('  Invalid input!')
		if PSU.ILIMIT <= 0.0:
			raise ValueError('Max. current must be positive.')
		if PSU.ILIMIT > PSU.IMAX:
			print ('  Adjusting current limit to max. output of the power supply (' + str(PSU1.IMAX) + ' A).')
			PSU.ILIMIT = PSU.IMAX

		try:
			PSU.PLIMIT = float(input('* ' + PSU.label + ' maximum allowed power (W): '))
		except ValueError:
			print ('  Invalid input!')
		if PSU.PLIMIT <= 0.0:
			raise ValueError('Max. power must be positive.')
		if PSU.PLIMIT > PSU.PMAX:
			print ('  Adjusting power limit to max. output of the power supply (' + str(PSU.PMAX) + ' W).')
			PSU.PLIMIT = PSU.PMAX

		PSU.configured = True

	return PSU




################
# main program #
################

# read config file:
config = configparser.ConfigParser()
config.read('curvetrace_config.txt')

# connect to PSUs:
PSU1 = connect_PSU(config,'PSU1');
PSU2 = connect_PSU(config,'PSU2');

# ask for sample name:
samplename = ''
while not samplename:
    samplename = input('Enter sample name / label: ')
    samplename = samplename.strip()

# start logfile:
logfilename = samplename + '.dat'

logfile = open(logfilename,'w')
if logfile:
    print('\nLogging output to ' + logfilename + '...')
else:
    print('Could not open log file!')
    exit()

# ask for voltage values / current and power limits:
PSU1 = configure_PSU (PSU1)
PSU2 = configure_PSU (PSU2)

if PSU1.configured == False:
	if PSU2.configured == False:
		print('No power suplly configured. Good bye.')
		exit()

# set up repeats:
try:
	N_rep = int(input('\nOPTIONAL: Number of repeats per reading [default=1]: '))
except ValueError:
	print ('  Using default: single reading.')
	N_rep = 1
if N_rep <= 0:
	raise ValueError('Number of repeats must be positive.')

# set up idling:
try:
	T_idle = float(input('\nOPTIONAL: idle time between readings (s) [default=0]: '))
except ValueError:
	print ('  Using default: no idle time.')
	T_idle = 0.0
if T_idle < 0:
	raise ValueError('Idle time must not be negative.')

if T_idle == 0.0:
	V_idle = 0.0;
	I_idle = 0.0
else:
	try:
		V_idle = float(input('OPTIONAL: voltage during idle (V, limit) [default=0]: '))
	except ValueError:
		print ('  Using default: idle voltage limit = ' + str(PSU1.VMIN) + ' V.')
		V_idle = PSU1.VMIN
	if V_idle < PSU1.VMIN:
		print ('  Adjusting idle voltage limit to min. value possible with the power supply (' + str(PSU1.VMIN) + ' V).')
		V_idle = PSU1.VMIN			
	if V_idle > PSU1.VMAX:
		print ('  Adjusting idle voltage limit to max. value possible with the power supply (' + str(PSU1.VMAX) + ' V).')
		V_idle = PSU1.VMAX
	if V_idle == 0.0:
		I_idle = 0.0
	else:
		try:
			I_idle = float(input('OPTIONAL: current during idle (A, limit) [default=1]: '))
		except ValueError:
			print ('  Using default: idle current limit = 0 A.')
			I_idle = 0.0
		if I_idle < 0:
			raise ValueError('Idle current limit must not be negative.')
		if I_idle > PSU1.IMAX:
			print ('  Adjusting idle current limit to max. output of the power supply (' + str(PSU1.IMAX) + ' A).')
			I_idle = PSU1.IMAX


# Print summary of test setup:
print('\nTest setup:')
printit('* Sample: ' + samplename,logfile,'%')
for p in [PSU1, PSU2]:
	if p.configured == False:
		printit ('* ' + p.label + ' not configured',logfile,'%')
	else:
		if p.N == 1:
			printit ('* ' + p.label + ' voltage output = ' + str(p.VSTART) + ' V',logfile,'%')
		else:
			printit ('* ' + p.label + ' voltage output = ' + str(p.VSTART) + ' V ... ' + str(p.VEND) + ' V (' + str(p.N) + ' steps)',logfile,'%')
		printit ('* ' + p.label + ' current limit = ' + str(p.ILIMIT) + ' A',logfile,'%')
		printit ('* ' + p.label + ' power limit = ' + str(p.PLIMIT) + ' W',logfile,'%')

printit ('* Repeats per reading = ' + str(N_rep),logfile,'%')
if T_idle == 0.0:
	printit ('* No idle time between measurements',logfile,'%')
else:
	if T_idle == 0:
		printit ('* No idle time between measurements',logfile,'%')
	else:
		printit ('* Idle time between measurements: ' + str(T_idle) + ' seconds',logfile,'%')
		for p in [PSU1, PSU2]:
			if p.configured == False:
				printit ('* ' + p.label + '* Idle conditions not configured',logfile,'%')
			else:
				printit ('* ' + p.label + ' voltage = ' + str(p.VIDLE) + ' V',logfile,'%')
				printit ('* ' + p.label + ' current = ' + str(p.IIDLE) + ' V',logfile,'%')


# Ask if okay to start the test
input ('\nReady? Press ENTER to start testing or CTRL+C to abort...')

# Run the test:
print ('\nTest started...\n')

printit ('Column 1:  PSU1 voltage setting (V)',logfile,'%')
printit ('Column 2:  PSU1 current setting (A)',logfile,'%')
printit ('Column 3:  PSU1 voltage measurement (V)',logfile,'%')
printit ('Column 4:  PSU1 current measurement (I)',logfile,'%')
printit ('Column 5:  PSU1 limiter flag',logfile,'%')
printit ('Column 6:  PSU2 voltage setting (V)',logfile,'%')
printit ('Column 7:  PSU2 current setting (A)',logfile,'%')
printit ('Column 8:  PSU2 voltage measurement (V)',logfile,'%')
printit ('Column 9:  PSU2 current measurement (I)',logfile,'%')
printit ('Column 10: PSU2 limiter flag',logfile,'%')

for V2 in np.linspace(PSU2.VSTART,PSU2.VEND,PSU2.N):

	if PSU2.configured:
		# Determine PSU2 current limit:
		if V2 > 0.0:
			I2LIM = min (PSU2.ILIMIT,PSU2.PLIMIT/V2)
		else:
			I2LIM = PSU2.ILIMIT
		
		# set PSU2 current limit:
		PSU2.current(I2LIM)
		PSU2.voltage(V2)
		time.sleep(PSU2.TSETTLE) # wait for stable conditions

	for V1 in np.linspace(PSU1.VSTART,PSU1.VEND,PSU1.N):

		# init measurement values		
		V1MEAS = 0.0
		I1MEAS = 0.0
		LIMIT1 = 0
		V2MEAS = 0.0
		I2MEAS = 0.0
		LIMIT2 = 0

		# measurement loop:
		for i in range(N_rep):

			if T_idle > 0.0:
				# set outputs to zero (to avoid overshoot)
				for p in [PSU1, PSU2]:
					if p.configured:
						p.voltage(p.VMIN)
						p.current(0)

				# set idle conditions:
				Tsettle = 0.0
				for p in [PSU1, PSU2]:
					if p.configured:
						p.voltage(p.VIDLE)
						p.current(p.IIDLE)
						if p.TSETTLE > Tsettle:
							Tsettle = p.TSETTLE
				time.sleep(Tsettle) # wait for stable conditions

				# wait idle time:	
				time.sleep(T_idle)

				# set outputs to zero (to avoid overshoot when starting next measurement)
				for p in [PSU1, PSU2]:
					if p.configured:
						p.voltage(p.VMIN)
						p.current(0)

				# return to required PSU2 output:
				if PSU2.configured:
					PSU2.current(I2LIM)
					PSU2.voltage(V2)
					time.sleep(PSU2.TSETTLE) # wait for stable conditions

			# Determine PSU1 current limit:
			if V1 > 0.0:
				I1LIM = min (PSU1.ILIMIT,PSU1.PLIMIT/V1)
			else:
				I1LIM = PSU1.ILIMIT

			# set up PSU1 measurement conditions:
			if PSU1.configured:
				PSU1.current(I1LIM) # set current limit at PSU1
				PSU1.voltage(V1) # set voltage at PSU1
				time.sleep(PSU1.TSETTLE) # wait for stable conditions at PSU and DUT

			# read PSU output voltages and currents:
			r = []
			for p in [PSU1, PSU2]:
				if p.configured:
					r.append(p.reading())
				else:
					r.append([0.0,0.0,'NONE'])

			V1MEAS = V1MEAS + r[0][0];
			I1MEAS = I1MEAS + r[0][1];
			V2MEAS = V2MEAS + r[1][0];
			I2MEAS = I2MEAS + r[1][1];
			if r[0][2] == 'CC':
				LIMIT1 = LIMIT1 + 1
			if r[1][2] == 'CC':
				LIMIT2 = LIMIT2 + 1

		# Determine mean of repeated readings:
		V1MEAS = V1MEAS / N_rep
		I1MEAS = I1MEAS / N_rep
		V2MEAS = V2MEAS / N_rep
		I2MEAS = I2MEAS / N_rep

		# Parse limiter flags:
		if LIMIT1 > 0:
			LIMIT1 = 1
		else:
			LIMIT1 = 0
		if LIMIT2 > 0:
			LIMIT2 = 1
		else:
			LIMIT2 = 0

		# Print results:
		printit ( str(V1) + ' ' + str(I1LIM) + ' ' + str(V1MEAS) + ' ' + str(I1MEAS) + ' ' + str(int(LIMIT1)) + ' ' + str(V2MEAS) + ' ' + str(I2MEAS) + ' ' + str(int(LIMIT2)) , logfile )


# Set PSU output to zero:
PSU1.voltage(PSU1.VMIN)
PSU1.current(0)
PSU2.voltage(PSU2.VMIN)
PSU2.current(0)

# Say goodbye:
print ('Test completed.')
