#!/usr/bin/env python3

# This file is part of PyPSUcurvetrace, a toolbox for I/V curve tracing of electronic parts using programmable power supplies.
#
# PyPSUcurvetrace is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# PyPSUcurvetrace is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with PyPSUcurvetrace.  If not, see <http://www.gnu.org/licenses/>.


# imports:
import time
import math
import datetime
import configparser
import argparse
import numpy as np
### from termcolor import colored
import lib.powersupply as powersupply


##########################################
# function to get number input from user #
##########################################

def __get_number(text,allowNegative = False,allowZero = True,typ='float'):
	input_ok = False
	while not input_ok:
		try:
			if typ.upper()=='FLOAT':
				val = float(input(text))
			elif typ.upper()=='INT':
				val = int(input(text))

			if not allowNegative:
				if val < 0.0:
					raise ValueError
			if not allowZero:
				if val == 0.0:
					raise ValueError

			input_ok = True

		except ValueError:
			print ('  Invalid input! Try again...')
	
	return val


#############################################################
# function to print output both to console and to data file #
#############################################################

def printit(text,f='',comm=''):
	print(text)
	if f:
		if len(comm):
			text = comm + ' ' + text
		print(text,file=f)
		f.flush()
	return


###########################
# connect to power supply #
###########################

def connect_PSU(configPSU,label):

	if not (label in configPSU):
		# print(label + ' not specified in configuration file. Leaving ' + label + ' unconfigured.')
		P = powersupply.PSU(label=label) # init empty PSU object

	else:
		if 'COMPORT' in configPSU[label]:
			port=configPSU[label]['COMPORT']
		else:
			print ('No COMPORT field in the PSU configuration file! Cannot continue.')
			exit()

		if 'TYPE' in configPSU[label]:
			commandset = configPSU[label]['TYPE']
		else:
			print ('No TYPE field in the PSU configuration file! Cannot continue.')
			exit()

		# connect to PSU:
		print ('Connecting to power supply ' + label + '...')
		P = powersupply.PSU(port,commandset,label)

		# set number of consistent readings for measurements:
		if 'NUMMEAS' in configPSU[label]:
			P.NSTABLEREADINGS = int(configPSU[label]['NUMMEAS'])
		else:
			print ('Number of consistent measurement readings not configured! Using N = 1...')
			P.NSTABLEREADINGS = 1
			
		if P.CONNECTED:

			# make sure the PSU output is turned off:
			P.turnOff()

			# show summary
			print ('* Command set: ' + P.COMMANDSET)
			print ('* Model: ' + P.MODEL)
			print ('* Min. voltage: ' + str(P.VMIN) + ' V')
			print ('* Max. voltage: ' + str(P.VMAX) + ' V')
			print ('* Max. current: ' + str(P.IMAX) + ' A')
			print ('* Max. power: ' + str(P.PMAX) + ' W')
			print ('* Number of consistent readings for measurements: ' + str(P.NSTABLEREADINGS))
			### print ('* Settle time: ' + str(PSU.settletime()) + ' s')

	return P



###############################
# configure PSU test settings #
###############################

def configure_test_PSU(PSU,configDUT):
	
	if not PSU.CONNECTED:
		print ('\n' + PSU.LABEL + ' is not connected (or connection is not configured).')
		PSU.CONFIGURED = False
	else:
	
		if configDUT:
			# take configuration from DUT config file:
			PSU.TEST_VSTART = float(configDUT['VSTART'])
			PSU.TEST_VEND   = float(configDUT['VEND'])
			PSU.TEST_N      = int(configDUT['N'])
			PSU.TEST_ILIMIT = float(configDUT['IMAX'])
			PSU.TEST_PLIMIT = float(configDUT['PMAX'])
			PSU.TEST_POLARITY = int(configDUT['POLARITY'])

		else:

			print ('\n' + 'configure ' + PSU.LABEL + ' test settings:')
			PSU.TEST_VSTART = __get_number('* ' + PSU.LABEL + ' start voltage (V): ',allowZero=True,allowNegative=False,typ='float')
			PSU.TEST_VEND   = __get_number('* ' + PSU.LABEL + ' end voltage (V): ',allowZero=True,allowNegative=False,typ='float')
			PSU.TEST_N      = __get_number('* ' + PSU.LABEL + ' number of voltage steps: ',allowZero=False,allowNegative=False,typ='int')
			PSU.TEST_ILIMIT = __get_number('* ' + PSU.LABEL + ' maximum allowed current (A): ',allowZero=False,allowNegative=False,typ='float')
			PSU.TEST_PLIMIT = __get_number('* ' + PSU.LABEL + ' maximum allowed power (W): ',allowZero=False,allowNegative=False,typ='float')
			try:
				pol = (input('* OPTIONAL: ' + PSU.LABEL + ' polarity of outputs -- N: normal / I: inverted [default=N]: '))
			except ValueError:
				print ('  Using default: normal polarity.')
				pol = 'N'
			if pol.upper() == 'I':
				PSU.TEST_POLARITY = -1
			else:
				PSU.TEST_POLARITY = 1;

		PSU.CONFIGURED = True

	return PSU



###############################
# configure PSU idle settings #
###############################

def configure_idle_PSU(PSU,configDUT):
	
	if PSU.CONFIGURED:

		if configDUT:
			# take configuration from DUT config file:
			PSU.TEST_VIDLE = float(configDUT['VIDLE'])
			PSU.TEST_IIDLE = float(configDUT['IIDLE'])

		else:
			print ('\n' + 'configure ' + PSU.LABEL + ' idle settings:')
			PSU.TEST_VIDLE = __get_number('* ' + PSU.LABEL + ' idle voltage (V): ',allowZero=True,allowNegative=False,typ='float')
			PSU.TEST_IIDLE = __get_number('* ' + PSU.LABEL + ' idle current (A): ',allowZero=True,allowNegative=False,typ='float')

	return PSU


################
# main program #
################

# parse input arguments (if any):
parser = argparse.ArgumentParser(description='PyPSUcurvetrace is a Python program for I-V curve tracing of electronic parts using programmable power supplies.')
parser.add_argument('-c', help='configuration file with test parameters (name/path)')
args = parser.parse_args()

# Say Hello:
print('\n')
print('***** PyPSUcurvetrace')
print('***** Python program for I-V curve tracing of electronic parts using programmable power supplies')
print('***** Disclaimer: NO WARRANTIES OF ANY KIND!!!')
print('***** Disclaimer: Users are advised to study the code in order to understand how this program works.')
print('\n')

# read PSU config file:
configPSU = configparser.ConfigParser()
configPSU.read('config_PSU.txt')

# read DUT configPSU file (if any):
configDUT = []
if args.c:
	print ('Reading DUT configuration in file ' + args.c + '...\n')
	configDUT = configparser.ConfigParser()
	configDUT.read(args.c)

# connect to PSUs:
PSU1 = connect_PSU(configPSU,'PSU1');
PSU2 = connect_PSU(configPSU,'PSU2');

# ask for sample name:
samplename = ''
while not samplename:
    samplename = input('Enter sample name / label: ')
    samplename = samplename.strip()

# start logfile:
logfilename = samplename + '.dat'

logfile = open(logfilename,'w')
if logfile:
    print('\nLogging output to ' + logfilename + '...')
else:
    print('Could not open log file!')
    exit()

# configure voltage values / current and power limits:
if 'PSU1' in configDUT:
	PSU1 = configure_test_PSU (PSU1,configDUT['PSU1'])
else:
	PSU1 = configure_test_PSU (PSU1,None)
if 'PSU2' in configDUT:
	PSU2 = configure_test_PSU (PSU2,configDUT['PSU2'])
else:
	PSU2 = configure_test_PSU (PSU2,None)

# check if at least one of the power supplies is configured:	
if not PSU1.CONFIGURED:
	if not PSU2.CONFIGURED:
		print('No power supply configured. Good bye.')
		exit()

# set up repeats:
if 'EXTRA' in configDUT:
	N_rep = int(configDUT['EXTRA']['NREP'])
else:
	try:
		N_rep = int(input('\nOPTIONAL: Number of repeats per reading [default=1]: '))
	except ValueError:
		print ('  Using default: single reading.')
		N_rep = 1
if N_rep <= 0:
	raise ValueError('Number of repeats must be positive.')

# set up idle time between readings:
if 'EXTRA' in configDUT:
	T_idle    = int(configDUT['EXTRA']['IDLESECS'])
else:
	try:
		T_idle = float(input('\nOPTIONAL: idle time between readings (s) [default=0]: '))
	except ValueError:
		print ('  Using default: no idle time.')
		T_idle = 0.0
if T_idle < 0:
	raise ValueError('Idle time must not be negative.')

# set up pre-heat time between readings:
if 'EXTRA' in configDUT:
	T_preheat    = int(configDUT['EXTRA']['PREHEATSECS'])
else:
	try:
		T_preheat = float(input('\nOPTIONAL: pre-heat time before starting the test (s) [default=0]: '))
	except ValueError:
		print ('  Using default: no pre-heating.')
		T_preheat = 0.0
if T_preheat < 0:
	raise ValueError('Pre-heat time must not be negative.')

# set up idle conditions (for pre-heat or idle between readings)
if (T_idle > 0.0) or (T_preheat > 0.0):
	if PSU1.CONFIGURED:
		if 'PSU1' in configDUT:
			PSU1 = configure_idle_PSU (PSU1,configDUT['PSU1'])
		else:
			PSU1 = configure_idle_PSU (PSU1,None)
	if PSU2.CONFIGURED:
		if 'PSU2' in configDUT:
			PSU2 = configure_idle_PSU (PSU2,configDUT['PSU2'])
		else:
			PSU2 = configure_idle_PSU (PSU2,None)

# check voltage / power / current limits (and fix where possible and necessary):
print ('\nChecking voltage / current / power limits...')
for p in [PSU1,PSU2]:
	if p.CONNECTED:
		if p.TEST_VSTART < p.VMIN:
			print ('  ' + p.LABEL + ': Adjusting start voltage to min. value possible with the power supply (' + str(p.VMIN) + ' V).')
			p.TEST_VSTART = p.VMIN
		if p.TEST_VSTART > p.VMAX:
			print ('  ' + p.LABEL + ': Adjusting start voltage to max. value possible with the power supply (' + str(p.VMAX) + ' V).')
			p.TEST_VSTART = p.VMAX
		if p.TEST_VEND < p.VMIN:
			print ('  ' + p.LABEL + ': Adjusting end voltage to min. value possible with the power supply (' + str(p.VMIN) + ' V).')
			p.TEST_VEND = p.VMIN
		if p.TEST_VEND > p.VMAX:
			print ('  ' + p.LABEL + ': Adjusting end voltage to max. value possible with the power supply (' + str(p.VMAX) + ' V).')
			p.TEST_VEND = p.VMAX
		if p.TEST_VEND == p.TEST_VSTART:
			print ('  ' + p.LABEL + ': Same start and end voltage! Using single step (N = 1).')
			p.TEST_N = 1
		if p.TEST_ILIMIT > p.IMAX:
			print ('  ' + p.LABEL + ': Adjusting current limit to max. value possible with the power supply (' + str(p.IMAX) + ' A).')
			p.TEST_ILIMIT = p.IMAX
		if p.TEST_PLIMIT > p.PMAX:
			print ('  ' + p.LABEL + ': Adjusting power limit to max. value possible with the power supply (' + str(p.PMAX) + ' W).')
			p.TEST_PLIMIT = p.PMAX
		if p.TEST_N < 1:
			print ('  ' + p.LABEL + ': Number of voltage steps with power supply (' + str(p.VMAX) + ' must be positive. Adjusting to N = 1.')
			p.TEST_N = 1
		if p.TEST_VIDLE > p.VMAX:
			print ('  ' + p.LABEL + ': Adjusting idle voltage to max. value possible with the power supply (' + str(p.VMAX) + ' V).')
			p.TEST_VIDLE = p.VMAX
		if p.TEST_VIDLE < p.VMIN:
			print ('  ' + p.LABEL + ': Adjusting idle voltage to min. value possible with the power supply (' + str(p.VMIN) + ' V).')
			p.TEST_VIDLE = p.VMIN
		if p.TEST_IIDLE > p.IMAX:
			print ('  ' + p.LABEL + ': Adjusting idle current to max. value possible with the power supply (' + str(p.IMAX) + ' V).')
			p.TEST_IIDLE = p.IMIN
		if p.TEST_VIDLE * p.TEST_IIDLE > p.PMAX:
			p.TEST_IIDLE = p.PMAX / p.TEST_VIDLE
			print ('  ' + p.LABEL + ': Idle current limit is higher than PSU power limit (' + str(p.PMAX) + ' W). Adjusting idle current limit to ' + str(p.TEST_IIDLE) + ' A.' )


# Print summary of test setup:
print('\nTest setup:')
printit('* Sample: ' + samplename,logfile,'%')
printit('* Date / time: ' + str(datetime.datetime.now()),logfile,'%')
for p in [PSU1, PSU2]:
	
	if not p.CONNECTED:
		printit ('* ' + p.LABEL + ': Not connected',logfile,'%')
	elif not p.CONFIGURED:
		printit ('* ' + p.LABEL + ': Test parameters not configured',logfile,'%')
	else:
		printit ('* ' + p.LABEL + ':',logfile,'%')
		printit ('  - Type: ' + str(p.COMMANDSET) + ' / ' + p.MODEL,logfile,'%')
		if p.TEST_N == 1:
			printit ('  - voltage output = ' + str(p.TEST_VSTART) + ' V',logfile,'%')
		else:
			printit ('  - voltage output = ' + str(p.TEST_VSTART) + ' V ... ' + str(p.TEST_VEND) + ' V (' + str(p.TEST_N) + ' steps)',logfile,'%')
		printit ('  - current limit = ' + str(p.TEST_ILIMIT) + ' A',logfile,'%')
		printit ('  - power limit = ' + str(p.TEST_PLIMIT) + ' W',logfile,'%')
		if p.TEST_POLARITY == 1:
			printit ('  - polarity: normal',logfile,'%')
		else:
			printit ('  - polarity: inverted',logfile,'%')

printit ('* Repeats per reading = ' + str(N_rep),logfile,'%')
if T_idle == 0.0:
	printit ('* No idle time between measurements',logfile,'%')
else:
	printit ('* Idle time between measurements: ' + str(T_idle) + ' s',logfile,'%')
if T_preheat == 0.0:
	printit ('* No pre-heating before measurements',logfile,'%')
else:
	printit ('* Pre-heat time before measurements (at idle conditions): ' + str(T_preheat) + ' seconds',logfile,'%')
if (T_idle > 0.0) or (T_preheat > 0.0):
	for p in [PSU1, PSU2]:
		if p.CONNECTED == False:
			printit ('* ' + p.LABEL + ' Idle / pre-heat conditions not configured',logfile,'%')
		else:
			printit ('* ' + p.LABEL + ' idle / pre-heat voltage limit = ' + str(p.TEST_VIDLE) + ' V',logfile,'%')
			printit ('* ' + p.LABEL + ' idle / pre-heat current limit = ' + str(p.TEST_IIDLE) + ' A',logfile,'%')


# Ask if okay to start the test
input ('\nReady? Press ENTER to start testing or CTRL+C to abort...')

# Run the test:

printit ('Column 1:  PSU1 nominal voltage setting (V)',logfile,'%')
printit ('Column 2:  PSU1 nominal current setting (A)',logfile,'%')
printit ('Column 3:  PSU1 voltage measurement (V)',logfile,'%')
printit ('Column 4:  PSU1 current measurement (I)',logfile,'%')
printit ('Column 5:  PSU1 limiter flag',logfile,'%')
printit ('Column 6:  PSU2 nominal voltage setting (V)',logfile,'%')
printit ('Column 7:  PSU2 nominal current setting (A)',logfile,'%')
printit ('Column 8:  PSU2 voltage measurement (V)',logfile,'%')
printit ('Column 9:  PSU2 current measurement (I)',logfile,'%')
printit ('Column 10: PSU2 limiter flag',logfile,'%')

print ('\n')

AVGFUNCTION = 'MEAN'
# AVGFUNCTION = 'MEDIAN'

V1_steps = np.linspace(PSU1.TEST_VSTART,PSU1.TEST_VEND,PSU1.TEST_N)
V2_steps = np.linspace(PSU2.TEST_VSTART,PSU2.TEST_VEND,PSU2.TEST_N)

try:

	# turn on PSU outputs:
	for p in [PSU1, PSU2]:
		if p.CONFIGURED:
			p.setCurrent(0,False)
			p.setVoltage(p.VMIN,False)
			p.turnOn()

	if T_preheat > 0.0:
		
		print ('Pre-heating...\n')

		# set outputs to zero (to avoid overshoot)
		# for p in [PSU1, PSU2]:
		# 	if p.CONFIGURED:
		# 		p.turnOff()

		# set idle conditions:
		### Tsettle = 0.0
		for p in [PSU1, PSU2]:
			if p.CONFIGURED:
				p.setCurrent(p.TEST_IIDLE,False)
				p.setVoltage(p.TEST_VIDLE,True)
				### Tsettle = max(p.settletime(),Tsettle)
		### time.sleep(Tsettle) # wait for stable conditions

		# wait pre-heat time:	
		time.sleep(T_preheat)

		# set outputs to zero (to avoid overshoot when starting next measurement)
		# for p in [PSU1, PSU2]:
		# 	if p.CONFIGURED:
		# 		p.turnOff()

	print ('Test started...\n')

	for V2 in V2_steps:

		if PSU2.CONFIGURED:

			# Determine PSU2 current limit (based on DUT limits):
			if V2 > 0.0:
				I2LIM = min (PSU2.TEST_ILIMIT,PSU2.TEST_PLIMIT/V2)
			else:
				I2LIM = PSU2.TEST_ILIMIT

			# Check if current limit is within power capability of PSU2 (and adjust if necessary):
			if (V2*I2LIM) > PSU2.PMAX:
				I2LIM = PSU2.PMAX / V2
			
			# set PSU2 voltage + current:
			PSU2.setCurrent(I2LIM,False)
			PSU2.setVoltage(V2,True)
			### time.sleep(PSU2.settletime()) # wait for stable conditions

		for V1 in V1_steps:

			# init measurement values		
			V1MEAS = []
			I1MEAS = []
			LIMIT1 = 0
			V2MEAS = []
			I2MEAS = []
			LIMIT2 = 0

			# measurement loop:
			for i in range(N_rep):

				if T_idle > 0.0:
					# set outputs to zero (to avoid overshoot)
					# for p in [PSU1, PSU2]:
					# 	if p.CONFIGURED:
					# 		p.setCurrent(0.0)

					# set idle conditions:
					### Tsettle = 0.0
					for p in [PSU1, PSU2]:
						if p.CONFIGURED:
							p.setCurrent(p.TEST_IIDLE,False)
							p.setVoltage(p.TEST_VIDLE,True)
							## Tsettle = max(p.settletime(),Tsettle)
					### time.sleep(Tsettle) # wait for stable conditions

					# wait idle time:	
					time.sleep(T_idle)

					# set outputs to zero (to avoid running hot before starting next measurement)
					for p in [PSU1, PSU2]:
						if p.CONFIGURED:
							p.setCurrent(0,False)

					# return to required PSU2 output:
					if PSU2.CONFIGURED:
						PSU2.setCurrent(I2LIM,False)
						PSU2.setVoltage(V2,True)
						# time.sleep(PSU2.settletime()) # wait for stable conditions

				# Determine PSU1 current limit:
				if V1 > 0.0:
					I1LIM = min (PSU1.TEST_ILIMIT,PSU1.TEST_PLIMIT/V1)
				else:
					I1LIM = PSU1.TEST_ILIMIT

				# Check if current limit is within power capability of PSU1 (and adjust if necessary):
				if (V1*I1LIM) > PSU1.PMAX:
					I1LIM = PSU1.PMAX / V1

				# set up PSU1 measurement conditions:
				if PSU1.CONFIGURED:
					PSU1.setCurrent(I1LIM,False) # set current limit at PSU1
					PSU1.setVoltage(V1,True) # set voltage at PSU1
					### time.sleep(PSU1.settletime()) # wait for stable conditions at PSU and DUT

				# wait a short moment to get everything stable:
				# time.sleep(0.1)

				# read PSU output voltages and currents:
				r = []
				for p in [PSU1, PSU2]:
					if p.CONFIGURED:
						r.append(p.read(p.NSTABLEREADINGS))
					else:
						r.append([0.0,0.0,'NONE'])
				
				V1MEAS.append(r[0][0])
				I1MEAS.append(r[0][1])
				V2MEAS.append(r[1][0])
				I2MEAS.append(r[1][1])
				if r[0][2] == 'CC':
					LIMIT1 = LIMIT1 + 1
				if r[1][2] == 'CC':
					LIMIT2 = LIMIT2 + 1

			# Determine median or mean of repeated readings:
			if AVGFUNCTION == 'MEDIAN':
				V1MEAS = np.median(V1MEAS)
				I1MEAS = np.median(I1MEAS)
				V2MEAS = np.median(V2MEAS)
				I2MEAS = np.median(I2MEAS)
			else:
				V1MEAS = np.mean(V1MEAS)
				I1MEAS = np.mean(I1MEAS)
				V2MEAS = np.mean(V2MEAS)
				I2MEAS = np.mean(I2MEAS)

			# Parse limiter flags:
			if LIMIT1 > 0:
				LIMIT1 = 1
			else:
				LIMIT1 = 0
			if LIMIT2 > 0:
				LIMIT2 = 1
			else:
				LIMIT2 = 0

			# Print results:
			printit ( str(V1*PSU1.TEST_POLARITY) + ' ' + str(I1LIM*PSU1.TEST_POLARITY) + ' ' + str(V1MEAS*PSU1.TEST_POLARITY) + ' ' + str(I1MEAS*PSU1.TEST_POLARITY) + ' ' + str(int(LIMIT1)) + ' ' + str(V2*PSU2.TEST_POLARITY) + ' ' + str(I2LIM*PSU2.TEST_POLARITY) + ' ' + str(V2MEAS*PSU2.TEST_POLARITY) + ' ' + str(I2MEAS*PSU2.TEST_POLARITY) + ' ' + str(int(LIMIT2)) , logfile )

	print ('Test completed.')
	for p in [PSU1, PSU2]:
		if p.CONNECTED:
			p.turnOff()

except:
	print ('\nOooops, something went wrong during testing! Trying to turn off the PSUs...\n')
	for p in [PSU1, PSU2]:
		if p.CONNECTED:
			p.turnOff()
	raise
